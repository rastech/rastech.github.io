<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Teches on Meta - Smarter Search</title>
    <link>https://meta.sc/tech/</link>
    <description>Recent content in Teches on Meta - Smarter Search</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© Meta</copyright>
    <lastBuildDate>Sun, 19 Jul 2015 03:01:25 -0400</lastBuildDate>
    <atom:link href="https://meta.sc/tech/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Starting Clean</title>
      <link>https://meta.sc/tech/startclean/</link>
      <pubDate>Sun, 19 Jul 2015 03:01:25 -0400</pubDate>
      
      <guid>https://meta.sc/tech/startclean/</guid>
      <description>

&lt;p&gt;When we started off designing the cloud architecture for Meta in February of 2015, it was with a totally clean slate. We had a vision for the experience that we wanted to create and requirements to go along with that, but no constraints from previously built technology or legacy infrastructure. While not an atypical position for a startup, we were thus positioned to choose a technology stack that fit our goals exactly while catering to the capabilities of our small team.&lt;/p&gt;

&lt;h2 id=&#34;product-requirements:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Product Requirements&lt;/h2&gt;

&lt;p&gt;To begin building out a product that matched the vision we had for Meta, we first had to outline what was required to build our product. A good starting point for this was the interactions we envisioned for users. Firstly, users should be able to search for their files and get back highly relevant results. Additionally, our system  must be able to perform analysis on the content of files to extract meaningful tags and metadata facilitating organization and our search. Lastly, we must be able to open a user&amp;rsquo;s files for them no matter the location of the file.&lt;/p&gt;

&lt;p&gt;Sitting at core of all this functionality is the ability to maintain centralized knowledge of where a user&amp;rsquo;s files are at all times, and to keep that snapshot always up to date. This presents a situation that is a little different from the challenge faced by most products. Rather than determining the best way to define resources unique to our system, we had to determine the best way to represent externally defined resources across an immense variety of systems.&lt;/p&gt;

&lt;p&gt;Our technology choices in building out our core infrastructure to solve these problems will be the topic of this blog post, enumerating our choices for the technology that Meta is built on and the motivations underlying them.&lt;/p&gt;

&lt;h2 id=&#34;formulating-an-architecture:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Formulating an Architecture&lt;/h2&gt;

&lt;p&gt;Boiling down the options for building a cloud application into a dichotomy, you have a choice between a monolith or microservices. Since we were starting our application from scratch with a goal of building out an MVP, starting with a monolithic application had a certain appealing features. We could punt on certain problems of scalability in order to focus on building something that works and then validate our idea with customers. Still, looking at the future of such a system presented problems. The concept of a &lt;a href=&#34;http://martinfowler.com/bliki/SacrificialArchitecture.html&#34;&gt;sacrificial architecture&lt;/a&gt; seemed like a painful transition for a system that was as distributed in nature as ours, and when you have a system that interfaces with such a wide variety of inputs as our does, it is pretty much impossible to create anything truly monolithic since we are receiving information form so many sources. Thus, even if we built a central monolith, we would still be working in a highly distributed environment, eroding some of the simplicity of a truly monolithic architecture.&lt;/p&gt;

&lt;p&gt;At the same time, implementing microservices in the fullest sense incurs significant development cost. Something that would otherwise be a simple function call turns into a network request, and a large number of APIs need to be well designed to encapsulate each piece of functionality in the system. Established companies, such as the classic example of &lt;a href=&#34;https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/&#34;&gt;Netflix&lt;/a&gt;, utilize hundreds of microservices to provide their services. Building an infrastructure with that amount of granularity from the start would be a bit foolish.&lt;/p&gt;

&lt;p&gt;We wanted to start off with an architecture that would facilitate transitioning to true microservices. Our current system has around a dozen separate services, and building with the design principles of service oriented architectures in mind will allow our application to be further subdivided in the future. Additionally, we were picking our technology stack in parallel with formulating our system architecture, so the flexibility of microservices to mix and match programming languages to suit specific problems was enticing.&lt;/p&gt;

&lt;h2 id=&#34;surveying-language-choices:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Surveying Language Choices&lt;/h2&gt;

&lt;p&gt;One of our primary goals for Meta&amp;rsquo;s UX is that our cloud based product should feel as fast and responsive as the interactions our customers are used to on a computer. In terms of our core architecture, this meant that changes occurring on your local machine should propagate through our system as quickly as possible. The system we are building is by nature eventually consistent; changes made to a files on user&amp;rsquo;s computer will always take some amount of time to propagate up to the our UI, but those changes must happen as quickly as possible, ideally fast enough for it to be perceived as instant.&lt;/p&gt;

&lt;p&gt;To facilitate reaching this goal, we needed to build out our architecture on a programming language that was lightning fast by default. We needed to have a baseline of response times in the tens of milliseconds, not in the hundreds. Our focus for the core infrastructure was thus shifted away from dynamic languages and heavier duty frameworks and towards more customizable and performance focused technologies.&lt;/p&gt;

&lt;h3 id=&#34;c-c:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;C/C++&lt;/h3&gt;

&lt;p&gt;When thinking about performance critical languages, C/C++ is probably the first thing that comes to mind. Developers are given precise and powerful control over the way that their application runs, and if done well the resulting applications are incredibly capable and performant. Still, these gains over didn&amp;rsquo;t outweigh the increase in complexity and potential for bugs. C/C++ didn&amp;rsquo;t seem like a great starting point to build an MVP of a cloud system.&lt;/p&gt;

&lt;h3 id=&#34;java-scala:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Java/Scala&lt;/h3&gt;

&lt;p&gt;JVM based languages offer speed and efficiency while eschewing manual memory management and other headaches of lower level languages. They have a mature and powerful ecosystem to support their products. Furthermore, during the summer of 2014 a proof of concept for Meta had been built out entirely in Scala, providing a code base that we could potentially leverage to speed up the development of our MVP. We actually did start off writing pieces of our application in Scala, but a few hiccups deterred us from pursuing it further. First of all, while the JVM is powerful, the complexity associated with deploying and tuning applications with complex build and dependency systems added overhead. Secondly, hiring great Scala developers is hard. While immensely powerful and expressive, the time it takes for a developer to get up to speed is much larger than for alternatives. The deal breaker was a lack of support for up to date Java technologies on on our chosen cloud platform, which I&amp;rsquo;ll get to shortly.&lt;/p&gt;

&lt;h3 id=&#34;go:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Go!&lt;/h3&gt;

&lt;p&gt;Go is the new kid on the block. Several things about it seemed like a good for for us. First of all, its performance was on par with JVM based languages despite its young age. We were also attracted to its simplicity and focus on explicit behavior. As our system grows in complexity, being able to track down issues across code bases would be increasingly important, and thus being able to approach code written by others is a helpful aspect of the language. Tools like &lt;code&gt;go fmt&lt;/code&gt; help enforce a uniform style.&lt;/p&gt;

&lt;p&gt;Additionally, Go is a simple language that can be learned in a matter of weeks, opening up our hiring requirements significantly. Still, that simplicity is not without costs. While some language features like higher order functions and the powerful concurrency primitives are top notch, there are areas where &lt;a href=&#34;http://yager.io/programming/go.html&#34;&gt;it is lacking&lt;/a&gt;. Ultimately though, for the class of problems we are working in, Go is a great fit for the core problems that we&amp;rsquo;re working on. We&amp;rsquo;ve been delighted with the language so far.&lt;/p&gt;

&lt;h2 id=&#34;deployment-and-infrastructure:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Deployment and Infrastructure&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve lost track of the time I&amp;rsquo;ve spent on various projects tinkering with server configuration files into the early hours of the morning, endeavoring to get some piece of infrastructure up and running or back online. While options such as &lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt;, and tools like &lt;a href=&#34;https://www.chef.io&#34;&gt;Chef&lt;/a&gt; and &lt;a href=&#34;https://puppetlabs.com&#34;&gt;Puppet&lt;/a&gt; can make this process easier and more automated, there is still a hump to get over before they start paying dividends. Some emerging technologies like &lt;a href=&#34;http://nixos.org&#34;&gt;NixOS&lt;/a&gt;, a functional and declarative operating system, seemed exciting, but I wanted to ensure that we spent our scarce development time focusing on the problems unique to our product rather than ones of infrastructure.&lt;/p&gt;

&lt;p&gt;Given this desire, PaaS (platform as a service) offerings had a lot of appeal. Since we had chosen Go as our primary development language, supporting it was a key criteria. A number of PaaS offerings are available on this front which we were evaluating in tandem.&lt;/p&gt;

&lt;p&gt;One platform coming into it&amp;rsquo;s own was Google App Engine. Since Go came out of Google, support for that language seemed like it was on a good path (validated by it&amp;rsquo;s &lt;a href=&#34;https://groups.google.com/forum/#!topic/google-appengine-go/as9wUqT77YU&#34;&gt;move to general availability&lt;/a&gt; recently!). When they offered us a spectacular credits program for established startups, we decided to go with App Engine. The microservices based design of our application allowed us to alleviate concerns about vendor lock-in, since any migration could be executed piece by piece and we could even split our infrastructure across providers if deemed necessary. While we may move away from PaaS solutions to options that give us more control over our application in the future, the ability to focus all our mental energy on the core of our product has been immensely valuable.&lt;/p&gt;

&lt;h2 id=&#34;conclusions:9849efcacdcb3a3ca94c1ee29050eb1c&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Choosing technology for an application is a difficult and often nebulous choice. There is no single right answer so questions about ways to do things better can always be raised and are healthy for the growth of product. Still, it seems that about once a week I come across an article about how X tech company just moved away from Y heavy duty framework to Z, giving them massive performance gains and cost savings. Pleasantly, the &amp;ldquo;Z&amp;rdquo; is often Go, validating our initial choices to a degree. While our initial launch may have been slightly slowed down by our focus on building a service based application that can scale effectively, we haven&amp;rsquo;t questioned that decision for a second. If you have confidence in a validated need for what you are building, start your product right and build your out a scalable architecture. Not something that can scale to millions of users tomorrow, but something that can grow and be expanded on by your team to facilitate the growth of your company. At Meta, we&amp;rsquo;re in the midst of roll out for our closed Beta and can&amp;rsquo;t wait to see where our platform can take us.&lt;/p&gt;

&lt;p&gt;If the challenges we&amp;rsquo;re facing interest you, check out our &lt;a href=&#34;https://meta.sc&#34;&gt;careers page&lt;/a&gt; and drop us a line at &lt;a href=&#34;mailto:careers@meta.sc&#34;&gt;careers@meta.sc&lt;/a&gt;. We&amp;rsquo;re hiring in every area of software engineering.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Facilitating Idiomatic Swift with Objective-C</title>
      <link>https://meta.sc/tech/swiftobjc/</link>
      <pubDate>Tue, 16 Jun 2015 09:38:02 -0400</pubDate>
      
      <guid>https://meta.sc/tech/swiftobjc/</guid>
      <description>

&lt;p&gt;At Meta, most of the work that has gone into our client applications thus far facilitates keeping our userâs files in sync with our cloud system so that they can be easily searched and accessed. When we began work on the client application for Mac OS X a few months ago, there were two major decisions that had to be made. The first was how to organize the application so that a resilient background process could listen for file system changes and keep everything up to date in the cloud. Iâll likely be discussing that in a future post. The second decision was what language to base the project in, which I will be discussing here.&lt;/p&gt;

&lt;p&gt;Since I was to be the primary developer of this application for the short term, this was partly a personal choice. While most of my experience in Apple&amp;rsquo;s world to date had been in writing Objective-C code, I had experimented with Swift and was excited to try it out in a production application. The were a few features in particular that I was attracted to in Swift.&lt;/p&gt;

&lt;p&gt;To start with, Swift&amp;rsquo;s concision was especially enticing. The ability to express oneself quickly is a desirable feature in any language, and fewer lines of code written means fewer lines of code to maintain. Another area of interest was the type safety, which Swift makes available through its data structures. Our system is largely event-based, with relatively complex data types passing information around about the state of a user&amp;rsquo;s files. In the back end, our use of structs provided by &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt; provides strong type safety in handling incoming data. Being able to work with similar guarantees on the client side is highly desirable. A third aspect that was appealing to me personally was the functional aspects of Swift. I enjoy programming in a functional style and Swift&amp;rsquo;s built in functionality for &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;, and the like were a great stimulus to try out the language further.&lt;/p&gt;

&lt;p&gt;Once the decision was made to use Swift as the primary language, development of our Mac application moved forward rapidly. Once the various components of the application were in place and structured, I began work on the meat of the application: handling changes to a user&amp;rsquo;s files. To interface with the file system on the level we required, much of the interaction occurs within the Core Foundation frameworks and in pure C code. As we tried to interface with these frameworks in Swift, a variety of issues came up.&lt;/p&gt;

&lt;h3 id=&#34;interfacing-with-uttype:ed2493891a91270524d133e14b0956ee&#34;&gt;Interfacing with UTType&lt;/h3&gt;

&lt;p&gt;Critical to analyzing a file&amp;rsquo;s content and displaying a meaningful description of a file to the user is knowing what kind of file you are dealing with. Cocoa&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/MobileCoreServices/Reference/UTTypeRef/&#34;&gt;UTType&lt;/a&gt; functionality provides us with the ability to extrapolate a file&amp;rsquo;s MIME type for use in our cloud services.&lt;/p&gt;

&lt;h4 id=&#34;swift:ed2493891a91270524d133e14b0956ee&#34;&gt;Swift&lt;/h4&gt;

&lt;p&gt;In Swift, my best attempt at interfacing with UTType is as follows in the code snippet below. There are two calls into the &lt;code&gt;UTType&lt;/code&gt; framework. The first requires a parameter of type &lt;code&gt;CFStringRef&lt;/code&gt;, which is easily created with a cast which utilized toll-free bridging behinds the scenes. The return value of this function is &lt;code&gt;Unmanaged&amp;lt;CFString&amp;gt;!&lt;/code&gt;, indicating that is an unannotated method where the memory management must be manually handled in Swift. The &lt;code&gt;takeRetainedValue()&lt;/code&gt; function is used because the value returned by this function as already been retained and needs to be released when the current scope is exited, thus removing the &lt;code&gt;Unmanaged&amp;lt;&amp;gt;&lt;/code&gt; wrapper from the inner type. Additionally, the failure case I have here is rather convoluted because it occurs when the &lt;code&gt;cfMimeType&lt;/code&gt; fails to bridge to a string, rather than explicitly from the return of the function call.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// this code crashes at runtime
public class func mimeTypeForFile(path: String) -&amp;gt; String {
    let ext = path.pathExtension as CFStringRef
    let UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, ext, nil).takeRetainedValue()
    
    let cfMimeType = UTTypeCopyPreferredTagWithClass(UTI, kUTTagClassMIMEType).takeRetainedValue()
    if let mimeType = cfMimeType as? String {
        return mimeType
    }
    return &amp;quot;application/octet-stream&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once I got this code compiling, I wrote a short unit test. Unfortunately when this code is run the following error occurs, a dreaded &lt;code&gt;EXC_BAD_INSTRUCTION&lt;/code&gt; runtime error. It is certainly possible that this code could be further massaged to get this example working (please let me know if you are able to), but after a good half hour or so I wasn&amp;rsquo;t able to find a solution.&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;width:100%;position:relative;&#34; src=&#34;https://meta.sc/blog/images/snippets/swift_uttype.png&#34; alt=&#34;Swift UTType interfacing&#34; title=&#34;Optional title&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;objective-c:ed2493891a91270524d133e14b0956ee&#34;&gt;Objective-C&lt;/h4&gt;

&lt;p&gt;Looking at the same code in Objective-C, several things are more desirable. Firstly, this code works; usually a desirable attribute in production code. No bad instructions errors here. Secondly, coming from a background of Objective-C, what is happening here is clearer than in the Swift code. Rather than dealing with wrappers on Core Foundation types meant to insulate Swift from pointers, you are dealing with the implementation directly and the underlying interactions are clearer. Since most developers writing Swift are coming from an Objective-C background, it should be explicitly clear what this code is doing in regard to memory management and error handling.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (NSString*) mimeTypeForFile:(NSString*) path {
    CFStringRef ext = (__bridge CFStringRef)[path pathExtension];
    CFStringRef UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, ext, NULL);
    CFStringRef mimeType = UTTypeCopyPreferredTagWithClass(UTI, kUTTagClassMIMEType);
    CFRelease(UTI);
    if (!mimeType) {
        return @&amp;quot;application/octet-stream&amp;quot;;
    }
    return CFBridgingRelease(mimeType);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;file-system-events:ed2493891a91270524d133e14b0956ee&#34;&gt;File System Events&lt;/h3&gt;

&lt;p&gt;Another area where we ran into issues was in our use of the &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html&#34;&gt;File System Events API&lt;/a&gt;, which provides a stream giving callbacks to your application when anything changes on the file system within a specified scope.&lt;/p&gt;

&lt;p&gt;What follows is my best attempt to create File System Event stream in pure Swift. There is a lot of syntactic baggage surrounding pointer handling and Core Foundation types, but theoretically all that should work just fine. The blocking issue is that a &lt;code&gt;CFuntionPointer&lt;/code&gt;, Swift&amp;rsquo;s type which is analogous to a normal function pointer in pure C code, cannot be created from either a Swift function or a closure. This is a limitation of the Swift language (until the recent 2.0 release, more on that later). The following code fails to compile because of this limitation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// this code does not compile
func testCreateSimpleSwiftListener() {
    let cfDirs = [NSHomeDirectory()] as CFArray
    let context = nil as UnsafeMutablePointer&amp;lt;FSEventStreamContext&amp;gt;
    let latency = 3.0 as CFAbsoluteTime
    let flags = kFSEventStreamCreateFlagFileEvents | kFSEventStreamCreateFlagWatchRoot
    
    let callback: @objc_block (
    ConstFSEventStreamRef,
    UnsafeMutablePointer&amp;lt;Void&amp;gt;,
    Int,
    UnsafeMutablePointer&amp;lt;Void&amp;gt;,
    UnsafePointer&amp;lt;FSEventStreamEventFlags&amp;gt;,
    UnsafePointer&amp;lt;FSEventStreamEventId&amp;gt;) -&amp;gt; Void = {
        (streamRef, clientCallBackInfo, numEvents, eventPaths, eventFlags, eventIds) -&amp;gt; Void in
        NSLog(&amp;quot;Received %i paths&amp;quot;, numEvents)
        // handle file event
    } as CFunctionPointer
    
    let stream = FSEventStreamCreate(
        kCFAllocatorDefault,
        callback as FSEventStreamCallback,
        context,
        cfDirs,
        kFSEventStreamEventIdSinceNow,
        latency,
        flags
    )
    FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode)
    FSEventStreamStart(stream)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the code with the compiler errors shown.&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;width:100%;position:relative;&#34; src=&#34;https://meta.sc/blog/images/snippets/swift_fsevents_func.png&#34; alt=&#34;Swift FSEvents interfacing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Again, with some further massaging this &lt;a href=&#34;http://stackoverflow.com/questions/25514176/using-swift-cfunctionpointer-to-pass-a-callback-to-coremidi-api#answer-29375116&#34;&gt;might&lt;/a&gt; or &lt;a href=&#34;http://dev.eltima.com/post/97718928834/interacting-with-c-pointers-in-swift-part-3&#34;&gt;might not&lt;/a&gt; be possible by delving further into the Objective-C runtime, but in doing so we yet again lose out on the most of the benefits of working in Swift at all. Even with this function pointer issue fixed, the &lt;code&gt;UnsafeMutablePointer&amp;lt;Type&amp;gt;&lt;/code&gt; and &lt;code&gt;UnsafePointer&amp;lt;Type&amp;gt;&lt;/code&gt; wrappers are uncomfortable to work with and a jarring change from the kind of Swift code that one can enjoy writing.&lt;/p&gt;

&lt;h3 id=&#34;reclaiming-the-benefits-of-swift:ed2493891a91270524d133e14b0956ee&#34;&gt;Reclaiming the benefits of Swift&lt;/h3&gt;

&lt;p&gt;In the previous two examples, nearly all of the reasons that I chose Swift for this project in the first place have been eroded to some degree. With the wrappers around low level objects, much of the concision disappeared. Since we are using Core Foundation types, type safety within data structures has withered. Lastly, higher level language features can only be applied after these low level types have been sufficiently dealt with. It basically feels like writing C code with more verbose and unfamiliar syntax.&lt;/p&gt;

&lt;p&gt;Ideally, when we are writing Swift we can focus on the benefits of the language, not how it interfaces with the very code it was meant to replace. The solution we ended up using here is to wrap interactions with Core Foundation and C APIs with simple Objective-C wrapper classes that provide a clean API for use by your Swift code. For us, this consisted primarily of two basic classes, &lt;code&gt;FileSystemListener&lt;/code&gt; and &lt;code&gt;FileSystemCrawler&lt;/code&gt;. The listener class is a wrapper around code dealing with the aforementioned &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html&#34;&gt;File System Events API&lt;/a&gt;, and the crawler wraps low level C code with interacts with the file system as efficiently as possible, enabling introspectable breadth-first crawls that can handle concurrent modifications to the file system.&lt;/p&gt;

&lt;p&gt;By providing these interfaces, the rest of our Swift code can interact with a purpose built API that dovetails nicely into our business logic, written in Swift, feeding changes to our events streams in the cloud. Additionally, it helps to reinforce good design principles in the realm of code modularity and separation of concerns, making your application more maintainable and testable moving forward.&lt;/p&gt;

&lt;h3 id=&#34;objective-c-and-swift:ed2493891a91270524d133e14b0956ee&#34;&gt;Objective-C and Swift&lt;/h3&gt;

&lt;p&gt;Interop between Objective-C and Swift at a higher level is a much friendlier affair, and most developers working in Swift probably have some experience in this area. Still, at the risk of paraphrasing the documentation, there were a few areas which were of particular interest to us that I would like to touch on. If this is an area where you are working in-depth, I would recommend that you to consult Apple&amp;rsquo;s documentation on &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-XID_0&#34;&gt;Using Swift with Cocoa and Objective-C&lt;/a&gt; directly for a much more thorough treatment of the topic.&lt;/p&gt;

&lt;h4 id=&#34;bridging:ed2493891a91270524d133e14b0956ee&#34;&gt;Bridging&lt;/h4&gt;

&lt;p&gt;The basis for interop between Objective-C and Swift is bridging between the two languages. Calling into Objective-C from Swift requires a bridging header to be inserted into your project, which Xcode will usually prompt you for, as shown below, when an Objective-C file is added to a Swift project. This file is linked to your build settings in the &lt;strong&gt;Swift Compiler - Code Generation&lt;/strong&gt; section as the &lt;strong&gt;Objective-C Bridging Header&lt;/strong&gt;. This header file contains import statements for the header files of Objective-C code that you wish to interact with. The Objective-C file that prompted its creation will be automatically added, and all subsequent files must be added manually.&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/bridgingheader_2x.png&#34; style=&#34;width:100%;position:relative;&#34;/&gt;&lt;/div&gt;

&lt;h4 id=&#34;syntactic-translation:ed2493891a91270524d133e14b0956ee&#34;&gt;Syntactic Translation&lt;/h4&gt;

&lt;p&gt;As &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_25&#34;&gt;documented&lt;/a&gt;, the Swift compiler performs translations of Objective-C syntax into Swift so that initializers, methods, and function calls can be performed natively from Swift code. Most of these conversions are fairly intuitive, and you have probably worked with some examples of these translations. The below example is a simplified version of a delegate of our &lt;code&gt;FileSystemListener&lt;/code&gt; class that wraps the FSEvents library using Objective-C.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol FileSystemListenerDelegate &amp;lt;NSObject&amp;gt;
-(void)fileCreateEvent:(FSEventStreamEventId)eventID atPath:(NSString*)path withFlags:(FSEventStreamEventFlags)flags;
-(void)fileModifyEvent:(FSEventStreamEventId)eventID atPath:(NSString*)path withFlags:(FSEventStreamEventFlags)flags;
-(void)fileRemoveEvent:(FSEventStreamEventId)eventID atPath:(NSString*)path withFlags:(FSEventStreamEventFlags)flags
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This stub of a Swift class demonstrates how the syntax translates between the two languages. Perhaps the translations are a bit more verbose than they could be, but it is still perfectly understandable and functional. And of course, Xcode&amp;rsquo;s auto complete functionality will fill out the translated function as you type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class FileHandler: FileSystemListenerDelegate {
    func fileCreateEvent(eventID: FSEventStreamEventId, atPath path: String!, withFlags flags: FSEventStreamEventFlags) {}
    func fileModifyEvent(eventID: FSEventStreamEventId, atPath path: String!, withFlags flags: FSEventStreamEventFlags) {}
    func fileRemoveEvent(eventID: FSEventStreamEventId, atPath path: String!, withFlags flags: FSEventStreamEventFlags) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;initializer-behavior:ed2493891a91270524d133e14b0956ee&#34;&gt;Initializer behavior&lt;/h5&gt;

&lt;p&gt;One behavior to be cognizant of in this translation is the handling of Optional types from potentially failable Objective-C initializers. Since Objective-C does not have a concept of Optionals, the default translation is auto-unwrapped Types, indicated with a bang at the end of the type, e.g. &lt;code&gt;Type!&lt;/code&gt;. Some APIs are annotated to indicate whether or not the initialization can fail, either eschewing an Optional wrapper of prompting the use of a normal Optional. For those that are not, the way auto-unwrapped Optionals work is that when accessed, the underlying value is implicitly unwrapped, causing a panic if the underlying value happens to be nil. If you are coming from an Objective-C background where we can happily send messages to &lt;code&gt;nil&lt;/code&gt; objects and move right along, this is definitely something to watch out for. As usual, this behavior is &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_27&#34;&gt;well documented&lt;/a&gt; within Apple&amp;rsquo;s treatment of the topic.&lt;/p&gt;

&lt;h4 id=&#34;data-types:ed2493891a91270524d133e14b0956ee&#34;&gt;Data Types&lt;/h4&gt;

&lt;p&gt;One area of concern in designing an interface between Objective-C and C code is the loss of type information for data structures. As I mentioned previously, one of the most attractive features in Swift initially was preserving type information, as opposed to untyped &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;NSDictionary&lt;/code&gt; objects. In the current release of Swift, these are still issues, but with a bit of care they can be handled gracefully.&lt;/p&gt;

&lt;p&gt;The following code snippet shows a simple example of optionally casting a &lt;code&gt;NSDictionary&lt;/code&gt; into a typed Swift dictionary. The &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-XID_47&#34;&gt;collection classes documentation&lt;/a&gt; has further examples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let d = NSDictionary(object: &amp;quot;value&amp;quot;, forKey: &amp;quot;key&amp;quot;)
if let data = d as? [String: String] {
    print(&amp;quot;data: \(data)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A very simple example of bridging between the &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; types by casting. When working with strings, methods for both &lt;code&gt;NSString&lt;/code&gt; and the builtin Swift &lt;code&gt;String&lt;/code&gt; types are available. Yet again, you can checkout the &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-XID_44&#34;&gt;strings documentation&lt;/a&gt; for further examples.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let n = &amp;quot;my string&amp;quot; as NSString
let s = n as String
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cocoapods:ed2493891a91270524d133e14b0956ee&#34;&gt;Cocoapods&lt;/h4&gt;

&lt;p&gt;We use Cocoapods for third party dependency management in the Meta client application. When experimenting with pods that are written in Swift, we came across an interesting aspect of the tool that I had previously been unaware of. Cocoapods has historically used static libraries, because while Mac has supported dynamic libraries for some time now, iOS has only supported them since the release of Swift. Static libraries work well for Objective-C, but as described by a &lt;a href=&#34;http://blog.cocoapods.org/CocoaPods-0.36/&#34;&gt;blog post&lt;/a&gt; on the release of Cocoapods 0.36, dynamic libraries are a requirement for Cocoapods written in Swift. The use of dynamic libraries is enabled by a &lt;code&gt;use_frameworks!&lt;/code&gt; line in your &lt;code&gt;Podfile&lt;/code&gt; specifying that your pods should be dynamically linked. If you have further interest in this topic, their &lt;a href=&#34;http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/&#34;&gt;previous blog post&lt;/a&gt; further illustrates the distinction.&lt;/p&gt;

&lt;h3 id=&#34;a-lingering-issue:ed2493891a91270524d133e14b0956ee&#34;&gt;A Lingering Issue&lt;/h3&gt;

&lt;p&gt;For the most part, when you move up out of interactions with Core Foundation and C code, interop between Objective-C and Swift just works. However, somewhere along the line we introduced a crash of the Swift compiler when building for release with optimizations, which is fixed by turning off the compiler optimizations, setting &lt;strong&gt;Optimization Level&lt;/strong&gt; to &lt;strong&gt;-Onone&lt;/strong&gt; in the &lt;strong&gt;Swift Compiler - Code Generation&lt;/strong&gt; section. When I gave this talk at &lt;a href=&#34;http://www.meetup.com/Boston-Swift/&#34;&gt;Boston Swift&lt;/a&gt;, an audience member brought up a &lt;a href=&#34;https://twitter.com/search?q=âoptimize.sil.neverâ&amp;amp;src=typd&#34;&gt;twitter discussion&lt;/a&gt; pointing to an annotation which may be useful in tracking down this bug. I&amp;rsquo;ll be diving into this in the coming weeks as we approach our closed beta launch, and if a solution is found I&amp;rsquo;ll post an update. Compiler optimizations can make an orders of magnitude difference in the performance of a program, so turning them off completely is quite undesirable.&lt;/p&gt;

&lt;!-- ![Swift compiler crash](https://meta.sc/images/blog/snippets/swift_compiler_error.png) --&gt;

&lt;h3 id=&#34;conclusions:ed2493891a91270524d133e14b0956ee&#34;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;When working with a new language, the last thing you want to do is try to code in the style of another language in a way that is non idiomatic. As a general rule of thumb, approaching a new language that way almost always results in less performant and less elegant code. In Swift, a lot of effort has been put in to ensure that developers can continue to interact with the existing C-based ecosystem surrounding Apple&amp;rsquo;s developer tools. While these tools are very useful for certain situations, they are far from a panacea where everything can be done in Swift. Choose your tools for the problem at hand, and when it comes to Mac and iOS development, that can mean thoughtful separation of concerns that allows you to have Swift and Objective-C existing within a simple application in a way that plays to the strengths of each language.&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3 id=&#34;updates-after-wwdc-2015:ed2493891a91270524d133e14b0956ee&#34;&gt;Updates after WWDC 2015&lt;/h3&gt;

&lt;p&gt;The development work underlying this blog post all took place before the 2015 WWDC conference last week. Two changes in particular help with some of the issues that are described above and I am very excited about trying them out within our application. With our preparations for the beta launch I have not yet had time to do so, but I&amp;rsquo;ll give my first impressions about the benefits they present.&lt;/p&gt;

&lt;h4 id=&#34;objective-c-generics:ed2493891a91270524d133e14b0956ee&#34;&gt;Objective-C Generics&lt;/h4&gt;

&lt;p&gt;One of the ongoing concerns I had with using Objective-C as opposed to Swift was the lack of type safety in data types. This has always been the status quo with Objective-C, but with the latest release of the Xcode 7 beta, support has been added for Objective-C generics, which will translate into typed Swift data structures. This is an exciting new feature and a great indicator that Apple is still putting significant effort into the development of Objective-C as well as Swift.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lightweight generics allow you to specify type information for collection classes like NSArray, NSSet, and NSDictionary. The type information improves Swift access when you bridge from Objective-C and simplifies the code you have to write. (6294649)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;cfunctionpointer-support:ed2493891a91270524d133e14b0956ee&#34;&gt;CFunctionPointer support&lt;/h4&gt;

&lt;p&gt;The central issue that blocked our efforts to use pure Swift was a lack of support for the &lt;code&gt;CFunctionPointer&lt;/code&gt; type. With the newest Xcode 7 beta release, support for function pointers has been added.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Native support for C function pointers: C functions that take function pointer arguments can be called using closures or global functions, with the restriction that the closure must not capture any of its local context. (16339559)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is an exciting change that would theoretically enable us to port the File System Events interactions to Swift. In combination with generics, many of my primary concerns have been alleviated. However, I think that the benefits of creating wrapper classes around these lower level APIs still hold. By abstracting away the complexity of the underlying functionality and providing a higher level API specific to your application, your code is more modular and more easily understandable. As Apple seeks to fortify Swift&amp;rsquo;s abilities, many of the issues I have run into will be undoubtedly be fixed. While the choice of language may fall more to the developer&amp;rsquo;s preference in the future, the principles of modularity will always apply.&lt;/p&gt;

&lt;p&gt;As we grow our team here at Meta, we want to make it as easy as possible for our newest team members to get up to speed and shipping code to our customers. If you&amp;rsquo;re interest in helping us simplify the complex and unsolved problem of finding files, reach out to us at &lt;a href=&#34;mailto:careers@meta.sc&#34;&gt;careers@meta.sc&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;slides:ed2493891a91270524d133e14b0956ee&#34;&gt;Slides&lt;/h2&gt;

&lt;p&gt;This blog post is based on a talk I gave for &lt;a href=&#34;http://www.meetup.com/Boston-Swift/&#34;&gt;Boston Swift&lt;/a&gt;. The slides are up on &lt;a href=&#34;http://www.slideshare.net/AaronTaylor20/swift-objc-49480894&#34;&gt;Slideshare&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;iframe src=&#34;https://www.slideshare.net/slideshow/embed_code/key/Bjr9W8CdCKOURA&#34; width=&#34;476&#34; height=&#34;400&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34;&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;h2 id=&#34;further-reading:ed2493891a91270524d133e14b0956ee&#34;&gt;Further Reading&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html&#34;&gt;Using Swift with Cocoa and Objective-C: Working with Cocoa Data Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html&#34;&gt;Using Swift with Cocoa and Objective-C: Interacting with C APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html&#34;&gt;Using Swift with Cocoa and Objective-C: Swift and Objective-C in the Same Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=6&#34;&gt;Interacting with C Pointers - Swift Blog - Apple Developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.eltima.com/post/93497713759/interacting-with-c-pointers-in-swift-part-2&#34;&gt;Mac Developers Blog - Interacting with C Pointers in Swift. Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.charlessoft.com/hacks/using_c_function_pointers_in_swift.html&#34;&gt;Horrible Coding Hack: Using C Function Pointers in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.cocoapods.org/CocoaPods-0.36/&#34;&gt;CocoaPods 0.36 - Framework and Swift Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/&#34;&gt;Pod Authors Guide to CocoaPods Frameworks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://adcdownload.apple.com/WWDC_2015/Xcode_7_beta/Xcode_7_beta_Release_Notes.pdf&#34;&gt;Xcode 7 beta release notes&lt;/a&gt; (requires apple developer account)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>